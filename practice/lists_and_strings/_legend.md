# Задание lists_and_strings

Задания на массивы и строки. Постарайтесь использовать стандартные функции языка и методы классов `list` и `str`, если в
задании не сказано обратное.

## Блок lists

Во всех функциях запрещено менять переданный в функцию массив, все операции стоит производить так, чтобы исходный массив
не менялся.

### `def sum_some(numbers, indices)`

Даны два массива `numbers` и `indices`. Требуется просуммировать числа из массива `numbers` на индексах, записанных в
массиве `indices` и вернуть эту сумму. Индексы в массиве `indices` могут повторяться.

Например, `sum_some([1, 2, 3], [0, 1, 1])` должен вернуть `1 + 2 + 2` &rightarrow; `5`.

### `def replace_range(a, b, x, y)`

Даны два массива `a` и `b`, а также два числа `x` и `y`. Гарантируется, что `0 <= x <= y < len(a)`. Требуется заменить
часть массива `a`, соответствующую позициям от `x` до `y` включительно, на массив `b`, и вернуть результат.

Например, `replace_range([1, 2, 3, 4], [7, 8, 9], 0, 1)` &rightarrow; `[7, 8, 9, 3, 4]`, так как это соответствует
замене `[a[0], a[1]]` на `[7, 8, 9]`.

### `def sum_list(a)`

Дан массив чисел `a`. **Рекурсивно** просуммируйте его элементы. Считайте, что сумма элементов пустого массива равна `0`
. Можете заводить дополнительные локальные функции, чтобы сделать это чуть более эффективно, не делая копии частей
массива `a` для рекурсивных вызовов.

Например, `sum_list([1, 2, 3])` &rightarrow; `6`

### `def signs(a)`

Дан массив чисел `a`. Верните массив, состоящий из элементов массива `a`, между которыми добавлены строки,
соответствующие знакам отношений (`'<'`, `'='`, `'>'`) между этими числами.

Например, `signs([2, 8, 4, 4])` &rightarrow; `[2, '<', 8, '>', 4, '=', 4]`

## Блок strings

### `def reverse(s)`

Дана строка `s`, верните ее же, записанную наоборот, то есть справа-налево.

Например, `reverse('abc')` &rightarrow; `'bca'`

### `def swap_case(s)`

Дана строка `s`, замените в ней все символы в нижнем регистре на символы верхнего, а все символы верхнего &ndash; на
символы нижнего. **Запрещено** (да, очень жаль) использовать стандартный метод строки `.swapcase()`.

Например, `swap_case('Hello world')` &rightarrow; `'hELLO WORLD'`

### `def censor(s, blacklist)`

Дана строка `s` и массив "запрещенных" слов `blacklist`. Замените все запрещенные слова в строке `s` на звездочки такой
же длины. Гарантируется, что `s` состоит только из букв и пробелов, словом считается последовательность букв,
ограниченная пробелами.

Например, `censor_words('hello world', ['hello'])` &rightarrow; `'***** world')`

### `def remove_duplicates(s)`

Дана строка `s`, удалите из нее идущие подряд повторы слов. Слова определяются так же, как и в предыдущем задании.

Например, `remove_duplicates('hello nice nice world hello')` &rightarrow; `'hello nice world hello'`

### `def parentheses(s)`

Дана строка `s`, состоящая из различных символов, а так же открывающих и закрывающих круглых скобок. Проверьте, что
скобки образуют правильную последовательность, то есть что каждой открывающей соответствует закрывающая, и наоборот.

Например, 
- `parentheses('(abc(1+2))')` &rightarrow; `True`
- `parentheses('(lalala')` &rightarrow; `False`
- `parentheses('(hello)world)')` &rightarrow; `False`
