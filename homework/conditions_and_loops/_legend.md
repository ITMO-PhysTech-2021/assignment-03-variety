# Задание conditions_and_loops

Задания на условия и циклы, в которых, кстати, тоже в большинстве уже написана часть кода. Так что некоторые функции
надо просто дополнить недостающими элементами, но некоторые &ndash; написать с нуля.

Напоминаю, что в тех функциях, где надо дополнить код, можно заменять только `...` или `_`.

## Блок conditions

### `def median(a, b, c)`

Даны три числа `a`, `b` и `c`. Требуется вернуть их медиану, то есть среднее из трех чисел.

Например, `median(2, 5, 3)` &rightarrow; `3`.

### `def get_or_none(a, index)`

Дан массив `a` и целое число `index`. Если `a[index]` существует, вернуть его, а иначе вернуть `None`.

Например, `get_or_none([1, 2, 3], 2)` &rightarrow; `3`, `get_or_none([1, 2], 2)` &rightarrow; `None`.

### `def is_power_of_two(x)`

Дано целое число `x`. Вернуть `True`, если `x` является степенью двойки, и `False` в противоположном случае.

Например, `is_power_of_two(8)` &rightarrow; `True`, `is_power_of_two(9)` &rightarrow; `False`.

### `def is_monotonic(a, b, c)`

Даны три числа `a`, `b` и `c`. Проверить, является ли `(a, b, c)` возрастающей или убывающей последовательностью.

Например, `is_monotonic(1, 2, 3)` &rightarrow; `True`, `is_monotonic(9, 5, 4)` &rightarrow; `True`
и `is_monotonic(6, 7, 6)` &rightarrow; `False`.

### `def inline_if(a, b, condition)`

Реализовать **в одну строку**. Переданы два значения `a` и `b`, и `condition`, равный либо `True`, либо `False`. В
зависимости от `condition` вернуть либо `a`, если он равен `True`, либо `b` иначе.

Например, `inline_if(1, 2, False)` &rightarrow; `2`.

## Блок `loops`

### `def is_increasing(a)`

Дан массив чисел `a`. Вернуть, правда ли, что его элементы строго возрастают (то есть что каждый следующий больше
предыдущего), или нет (то есть вернуть `True` или `False`).

Например, `is_increasing([1, 2, 6, 10])` &rightarrow; `True`, `is_increasing([1, 4, 2])` &rightarrow; `False`.

### `def twice_as_much(a)`

Дан массив `a`. Вернуть массив, состоящий из элементов массива `a`, увеличенных в два раза. Гарантируется, что все
объекты в `a` можно без ошибок умножать на 2.

Например, `twice_as_much([1, 'ab'])` &rightarrow; `[2, 'abab']`.

### `def count_oddity(a)`

Дан массив целых чисел `a`. Посчитайте количество четных и нечетных чисел в массиве и верните пару из полученных
количеств.

Например, `count_oddity([1, 2, 3, 5])` &rightarrow; `(1, 3)`.

### `def pick_until(a, stop)`

Дан массив `a` и некоторое значение `stop`. Вернуть наибольший префикс (начало) массива `a`, состоящий из элементов, не
равных `stop`. Иными словами, брать элементы `a` в ответ, пока не будет встречен конец `a` или элемент, равный `stop`.

Например, `pick_until([1, 2, 7, 1, 4, 3], 4)` &rightarrow; `[1, 2, 7, 1]`.

### `def sum_until(a, stop)`

Дан массив неотрицательных чисел `a` и неотрицательное число `stop`. Вернуть максимальную сумму на префиксе (начале) `a`
, не превосходящую `stop`. Иными словами, суммировать элементы `a`, пока не будет встречен конец `a` или пока итоговая
сумма будет не больше `stop`.

Например, `sum_until([1, 2, 7, 1, 4, 3], 13)` &rightarrow; `11`, равное `1 + 2 + 7 + 1`.